**1.简述 OSI 七层协议。
	TCP/IP               OSI七层模型           每层的物理设备                     每层运行常见的协议
						   应用层
						   表示层
	应用层                 会话层
	传输层                 传输层               四层交换机  四层路由器              TCP/UDP协议
	网络层                 网络层               三层交换机  路由器                  IP协议
	网络接口层             数据链路层            网桥 交换机 网卡                   ARP协议
						  物理层               中继器 集线器 双绞线
	作用：帮助不同类型的主机实现数据传输
	物理层功能：定义物理设备标准,网线的接口类型,为数据链路层提供物理连接
	数据链路层:定义了如何传输数据。通过ARP协议获取到mac地址
	网络层：负责路由，为两个主机系统之间提供连接和路径选择
	传输层：对发出的数据进行封装
	应用层：为应用软件提供服务

2.什么是C/S和B/S架构？
	c/s 客户端--服务端  如：qq 微信
	B/s 浏览器---服务端 通过网页访问

**3.简述 三次握手、四次挥手的流程。

    TCP共有6个标志位:
        SYN 置1时用来发起一个连接。
        ACK 置1时表示确认号（为合法，为0的时候表示数据段不包含确认信息，确认号被忽略。
        FIN 置1时表示发端完成发送任务。用来释放连接，表明发送方已经没有数据发送了
        URG 紧急数据标志  表示本数据包中包含紧急数据。用来保证TCP连接不被中断，并督促中间层设备尽快处理这些数据
        PSH 数据包到达接收端后,立即传给应用程序，而不必等到缓冲区满时才传送。
        RST 置1时重建连接。如果接收到RST位时候，通常发生了某些错误。

	TCP三次握手的过程如下：
	1.客户端发送SYN（SEQ=x）报文给服务器端，进入SYN_SEND状态。
	    SYN: 同步字符,是TCP/IP建立连接时使用的握手信号.
	    在发送信息或回答之前，都要先发送同步字符，用以实现或保持发送站和接收站之间的同步
	2.服务器端收到SYN报文，回应一个SYN （SEQ=y）+ ACK(ACK=x+1）报文，进入SYN_RECV状态。
	    ACK:确认字符，表示发来的数据已确认接收无误。
	        接收站对所收到的报文进行检查，若未发现错误，便向发送站发出确认回答ACK，表明信息已被正确接收，并准备好接收下一份报文
	    NAK:否认字符
	3.客户端收到服务器的SYN+ACK包，回应一个ACK(ACK=y+1）报文，进入Established（TCP连接成功）状态。
	三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了。

	四次挥手流程：
		由于TCP连接是全双工的，因此每个方向都必须单独进行关闭.当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。
		收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据

		（1） TCP客户端发送一个FIN(结束连接)，用来关闭客户到服务器的数据传送。
		        客户端发送一个FIN=M ,客户端进入FIN_WAIT_1状态。意思是说"我客户端没有数据要发给你了"，
		        但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。
        （2） 服务器收到这个FIN，它发回一个ACK
                服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。
                服务端进入CLOSE_WAIT(关闭等待)状态，这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。
        （3） 服务器关闭客户端的连接，发送一个FIN给客户端。
                当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。
                服务器端进入LAST_ACK(最后确认)状态
        （4） 客户端发回ACK报文确认
                客户端收到FIN=N报文后，就知道可以关闭连接了，但是他不相信网络，怕服务器端不知道要关闭，
                所以发送ack=N+1后进入TIME_WAIT(时间等待)状态，如果Server端没有收到ACK则可以重传。
                服务器端收到ACK后，就知道可以断开连接了,进入CLOSED状态。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，
                那好，我客户端也可以关闭连接了,进入CLOSED状态。

4.什么是arp协议？
	地址解析协议。根据ip地址获取mac地址
	主机发送消息时,将包含目标ip地址的ARP广播到网络上所有的主机,目标主机收到广播消息后
	将自己的ip和mac地址返回
**5.TCP和UDP的区别？
	TCP---传输控制协议,提供的是面向连接、可靠的字节流服务。
	1.通信之前必须先建立一个TCP连接，之后才能传输数据。
	2.TCP提供超时重发,丢弃重复数据,检验数据等功能。保证数据能从一端传到另一端。 
	UDP---用户数据报协议,提供的是无连接的，面向消息的不可靠服务。
	1.通信前不需创建连接
	2.UDP只把数据报发送出去，但是并不能保证它们能到达目的地。
	3.UDP传输速度很快
	4.每一条TCP连接只能是点到点的;UDP支持一对一,一对多,多对一和多对多的交互通信
		
6.什么是局域网和广域网？
	局域网和广域网是按规模大小而划分的两种计算机网络。
	局域网,简称LAN，是指在某一区域内由多台计算机互联成的计算机组。
			“某一区域”指的是同一办公室、同一建筑物、同一公司和同一学校等，一般是方圆几千米以内。
	广域网,简称WAN，是一种跨越大的、地域性的计算机网络的集合。
		通常跨越省、市，甚至一个国家。广域网包括大大小小不同的子网，子网可以是局域网，也可以是小型的广域网。

**7.为何基于tcp协议的通信比基于udp协议的通信更可靠？
		TCP通信必须建立连接,连接就遵循三次握手双向机制,这一机制保证校验了数据,保证了它的可靠性
		UDP:不需要建立连接 一直发数据，不需要对方回应

8.什么是socket？简述基于tcp协议的套接字通信流程。
	Socket是应用层与TCP/IP协议族通信的中间软件抽象层,它是一组接口
	把复杂的TCP/IP协议族隐藏在Socket接口后面.让Socket去组织数据,实现了相同主机或不同主机进程间的互相通信
	套接字:
		TCP用主机的IP地址加上端口号作为TCP连接的端点,这种端点就叫做套接字（socket）或插口
	套接字有两种：
		基于文件型：套接字家族的名字：AF_UNIX
		基于网络型：套接字家族的名字：AF_INET
	通信流程：
		1.服务端
			创建TCP套接字对象
			绑定ip端口
			开始监听请求
			接收发送数据
	 
		2.客户端
				创建TCP套接字对象
				连接指定IP端口
				接收发送数据
**9.什么是粘包？ socket 中造成粘包的原因是什么？哪些情况会发生粘包现象？
	只有TCP有粘包现象，UDP永远不会粘包
	1.黏包的概念：
		同时执行多条命令之后，得到的结果很可能只有一部分
		在执行其他命令的时候又接收到之前执行的另外一部分结果，这种现象就是黏包。
	2.产生黏包的原因：
		1.从表面上看,黏包问题主要是因为发送方和接收方的缓存机制、tcp协议面向流通信的特点。
		2.实际上,主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的
	3.发生黏包的两种情况：
		1.发送方的缓存机制：
		发送端需要等缓冲区满才发送出去
		发送端多次send间隔较短，并且数据量较小，tcp会通过Nagle算法，封装成一个包，发送到接收端，
		接收端不知道这个包由几部分组成，所以就会产生粘包。
		2.接收方的缓存机制
		数据量发送的大,接收端接收的小,再接一次，会出现上次没有接收完成的数据。就会出现粘包
	4.黏包的解决方案
		为字节流加上自定义固定长度报头，报头中包含字节流长度，然后一次send到对端，
		对端在接收时，先从缓存中取出定长的报头，然后再取真实数据。在python中利用struct模块
***10.IO多路复用的作用？
	检测多个socket的变化(是否有人连接,是否有内容发来)
    IO多路复用中监听了一个服务端的socket和客户端的socket
    服务端的socket的只有一种变化,有人连接就发生变化
    监听客户端的作用：监听是否有数据
    Python之基于socket和select模块实现IO多路复用：
        - select，监听socket个数：1024，轮训查看(主动一个个询问)  支持win
        - poll，监听socket无个数限制，轮训查看                   支持win
        - epoll，监听socket无个数限制，通过回调的方式检测socket变化。(socket有变化就收到消息)  不支持win 只支持linux
        selectors模块根据平台选出最佳的IO多路机制，比如在win的系统上默认的是select模式而在linux上它默认的epoll

11.什么是防火墙以及作用？
	它是一种位于内部网络与外部网络之间的网络安全系统。
	作用：对请求和端口进行过滤
12.select、poll、epoll 模型的区别？
（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。
	而epoll其实也需要调用 epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，
	但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在 epoll_wait中进入睡眠的进程。
	虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，
	而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。
（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，
	而epoll只要 一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，
	只是一个epoll内 部定义的等待队列）。这也能节省不少的开销。

***13.简述 进程、线程、协程的区别 以及应用场景？
	进程:
		资源分配的最小单位。是程序在处理机上的一次执行过程。进程间相互独立,内存隔离,一个进程修改数据不会影响其他进程
	线程:
		是CPU调度的最小单位，是进程中的一部分,一个进程内至少有一个线程,也可以开启多个线程,
		线程之间资源共享.一个线程修改数据其他线程也会受影响.
	协程:
		是单线程下的并发.本质上是一个线程,能够在多个任务之间切换来节省一些IO时间
	区别：
		1.进程/线程之间的调度靠操作系统,协程是由用户程序自己控制调度的。
		2. 进程和线程都是同步机制,协程是异步机制。
		3.协程可以保留上一次的执行状态,每次过程重入时，相当于进入上一次调用状态，协程只有在I/O密集型操作才会提高效率
		4.多线程,协程用于IO密集型，如socket，爬虫，web,抢占cpu资源
		5.多进程用于计算密集型，如金融分析,利用多核优势
		
	什么时候使用多进程，什么时候使用多线程：
		1.需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的
		2.线程的切换速度快，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应
		3.多机分布的用进程，多核分布用线程；
		4.需要更稳定安全时，适合选择进程；需要速度时，选择线程更好
	
	多进程与多线程的区别；CPU密集型适合用什么；
		多线程：在单个程序中同时运行多个线程完成不同的工作,称为多线程
		1.线程共享内存空间,进程的内存是独立的
			原因:进程资源分配的最小单位,线程没有自己的独立空间。因此对于地址空间和资源来说进程之间相互独立，各线程之间共享
		2.同一个进程的线程之间可以直接交流,两个进程想通信，必须通过一个中间代理(队列和管道)来实现
		3.多进程的优点是稳定性好，一个子进程崩溃了，不会影响主进程以及其余进程
			缺点是创建进程的代价非常大，因为操作系统要给每个进程分配固定的资源
		4.多线程优点是效率较高一些，但是致命的缺点是任何一个线程崩溃都可能
             造成整个进程的崩溃，因为它们共享了进程的内存资源池
		CPU密集型适合用多进程
	
	请解释为什么Python需要协程?
		cpu正在运行一个任务,会在两种情况下切走去执行其他的任务（切换由操作系统强制控制）,一种情况是该任务发生了阻塞,另外一种情况是该任务计算的时间过长
		对于单线程下,会不可避免程序中出现io操作, 同步IO下系统需要切换线程，让操作系统可以在IO过程中执行其他的东西。
		但是由于大量的线程切换带来了大量的性能的浪费.
		异步IO,就是当数据到达的时候触发我的回调。来减少线程切换带来性能损失。 
		但是这样的坏处也是很大的，每次来段数据就要判断数据够不够处理,够处理就处理吧,不够处理就在等等吧。
		但是使用协程每当触发IO操作的时候就自动让出CPU给其他协程。协程的切换很轻的,协程通过这种对异步IO的封装 
		既保留了性能也保证了代码的容易编写和可读性。这样就保证了该线程能够最大限度地处于就绪态，即随时都可以被cpu执行的状态，
		
	协程发生io操作时,是阻塞的还是非阻塞的？
		是非阻塞的。如果是阻塞的，必须得到结果后才能执行后面的操作，那么使用协程将毫无意义
	
	实现进程: multiprocessing
			开启进程两种方式：
				1.给Process传参
					from multiprocessing import Process
					def task(name):
						print('%s is running'%name)
					p1 = Process(target=task,args=('kebi',))
					p1.start() 
				2.使用类继承继Process
				class Myclass(Process): 
					def __init__(self,name):pass
					def run(self):pass
				p = Myclass('cx')
				p.start()
	实现线程: threading
		from threading import Thread
		开启进程两种方式：
			1.给Thread传参
			2.使用类继承继Thread
	
	如何实现协程：
		1.python提供了greenlet,相当于手动切换
			gr2 = greenlet(test2)
			gr2.switch()   # 切换去执行test2
		2.gevent 实现协程
			Gevent 是一个第三方库,主动识别程序内部的IO操作,当子程序遇到IO后,切换到别的子程序。如果所有的子程序都进入IO，则阻塞。
			def func1():
				print("func1 running")
				gevent.sleep(2)
			def func2():
				print("func1 running")
				gevent.sleep(2)
			gevent.joinall([gevent.spawn(func1),gevent.spawn(func2)])

进程池和线程池：
	进程池内部维护一个进程序列，当使用时，则去进程池中的获取一个进程，
	如果进程池序列中没有可供使用的进程，那么进程就会等待，直到进程池中有可用进程为止
	线程池也是类似。
	进程池:
		from concurrent.futures import ProcessPoolExecutor
		def func(name):pass
		if __name__ == "__main__":
			p = ProcessPoolExecutor(3)  #创建一个进程池，里面容纳3个进程
			for i in range(7):
				obj = p.submit(func,'科比%i'%i)
	线程池:
		from concurrent.futures import ThreadPoolExecutor
		def func(name):pass
		if __name__ =="__main__":
			t = ThreadPoolExecutor(3)   #默认是CPU的核数*5
			for i in range(7):
				obj = t.submit(task,i)
***14.GIL锁是什么鬼？
	全局解释器锁,约束线程在同一时间只能有一个线程访问cpu
	多个进程有多个GIL锁，但每个进程中只有一个GIL
	GIL的特点：
		1.锁的是线程, 而不是数据，无法保证数据的安全。 
		2.同一时刻只有一个线程访问CPU
	
	守护进程和守护线程的作用：
		用于监控指定的进程/线程,当发现目标进程/线程不再正常工作时,就关闭该进程,并重启它

15.Python中如何使用线程池和进程池？
		进程池：使用multiprocessing.Pool 
        线程池：使用ThreadPool模块  
		
16.threading.local的作用？
	多线程操作时,为每个线程创建一个值。使得线程之间个字操作自己的值,互相不影响。
	一旦在主线程实例化了一个local，它会一直活在主线程中，并且又主线程启动的子线程调用这个local实例时，
	它的值将会保存在相应的子线程中。
	使用场景:为每个线程绑定一个资源
	import time
	import threading

	obj = threading.local()
	def task(i):
		obj.val = 0
		time.sleep(2)
		obj.val += 1
		print(obj.val)
	for i in range(5):
		t = threading.Thread(target=task,args=(i,))
		t.start()   #1 1 1 1  1

***17.进程/线程之间如何进行通信？
	进程之间通信方式：(IPC)—队列和管道
		1.Queue的使用：Queue是多进程安全的队列        
			put方法将数据插入到队列中        
			Get方法从队列中拿走一个数据 
			q.put()如果队列已经满了,程序阻塞,等待数据被别人取走,再将数据放入队列。
			   如果队列中的数据一直不被取走，程序就会阻塞。
			q.get()如果队列中数据为为空,停在这,一直等待数据(即阻塞）
			q.full() 判断队列是否满了
		2.Pipe的使用    
			pipe用于两个进程间的通信,两个进程分别位于管道的两端,Pipe方法返回(conn1,conn2)代表一个管道的两端, 
			Pipe方法有dumplex参数,若该参数为True,管道为全双工模式,若为Fasle,conn1只负责接收消息,conn2只负责发送消息.    
			send和recv方法分别是发送和接收消息的方法, close: 关闭管道口  一般在进程中用不到的管道口就可以先关闭掉
			
		3.信号量机制：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。
		
		4.信号:信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生
		
	线程之间通信方式：
		1.锁机制：包括互斥锁 读写锁
			互斥锁提供了以排他方式防止数据结构被并发修改的方法。
			读写锁允许多个线程同时读共享数据，而对写操作是互斥的
			
		2.信号量机制
		
		3.信号


	进程之间如何共享变量：
	    1.Value  共享数值型变量
	        num=multiprocessing.Value("d",10.0) # d表示数值,主进程与子进程共享这个value。（主进程与子进程都是用的同一个value)

	    2.Array 共享数组性
            num=multiprocessing.Array("i",[1,2,3,4,5])   #主进程与子进程共享这个数组

        3.Manager 共享dict list
            mydict=multiprocessing.Manager().dict()   #主进程与子进程共享这个字典
            mylist=multiprocessing.Manager().list(range(5))   #主进程与子进程共享这个List

	
	
	进程的三态：
		进程三态：就绪，运行和阻塞
			（1）就绪(Ready)状态
					当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。
			（2）执行/运行（Running）状态
					当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态。
			（3）阻塞(Blocked)状态
					正在执行的进程,由于等待某个事件发生而无法执行时,便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，
					例如，input sleep 文件的输入书输出 网络请求 recv send
		
18.什么是并发和并行？
	并发:是一个伪异步.在多线程中,看起来是一起执行,实际上是cpu一直在切换着工作
		GIL在同一时刻限制了多个线程，只有一个线程被CPU执行.
	并行：是真正的异步.在多进程中,多个进程在同一时刻占用多个cpu。互不干扰+


**19.进程锁和线程锁的作用？
	进程锁: 防止多个进程同时操作一套文件系统
	线程锁: 防止多个线程同时修改进程内数据
	Lock互斥锁:
		进程锁:
			当多个进程需要访问共享资源的时候，Lock可以用来避免访问的冲突
			当多个进程同时使用同一份数据资源的时候，就会引发数据安全或顺序混乱问题
			加锁可以保证多个进程修改同一块数据时，同一时间只能有一个任务可以进行修改，即串行的修改
		线程锁:
			多线程使用共享资源时，不加锁会造成数据不安全。
	
	线程中有了GIL锁为什么还要加线程锁?
		GIL锁锁的是线程。保证同一时刻只有一个线程在运行。当A线程运行,拿到共享资源后,还没来得及处理,时间片切换到B线程,B线程拿到
		的是未处理的资源，因此造成数据不安全。需要加锁来避免线程间冲突
		不是python语言的问题，是Cpython解释器的特征
	
	死锁与递归锁：
		指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。
		解决方法:递归锁(RLock):支持在同一线程中多次请求同一资源
		Lock在同一个进程或者线程中，只能acquire一次，如两个acquire时，就会阻塞，产生死锁
		RLock在同一个进程或者线程中，无论有多少个acquire都不会阻塞
		但是acquire和release必须成对出现 n次acquire，需要n次release

20.解释什么是异步非阻塞？
	同步:只存在一个线程,是一种可靠的任务序列
		同一时间,只能做一个任务。一个任务的完成需要依赖另外一个任务
	异步:存在多条线程,是不可靠的任务序列
		同一时间,能做多个任务。一个任务的完成不需要依赖另外一个任务
	异步非阻塞：在同一时刻,各自的进程或者线程中存在着IO操作.在等待消息通知时不会被阻塞

21.路由器和交换机的区别？
	路由器: 亦称选径器
		   工作于OSI模型的网络层，能够识别IP地址,
		   并根据IP地址转发数据包,并维护着路由表，能够基于路由表进行最佳路线选择；
		   路由器提供了防火墙的服务
	交换机: 
		   交换机工作于OSI模型的数据链路层,能够识别MAC地址,内部有张桥表
		   根据桥表上MAC地址和端口的对应关系进行数据帧转发。

22.什么是域名解析？
	域名到IP地址的转换,我们在浏览器上输入网站域名时,会先获取该域名对应的IP地址,再去访问该地址
	
	当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到,系统会立即打开对应网页，
	如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。
	Hosts的IP解析优先级比DNS要高。
23.如何修改本地hosts文件？
	win : C:\Windows\System32\drivers\etc\hosts 
	linux : /etc/hosts
	在最后新增如下内容：
	127.0.0.1 www.163.com
	表示域名“www.163.com”指向的ip为127.0.0.1，即本地

24.生产者消费者模型应用场景及优势？
	1.应用场景:
		由一个线程生成订单,并将其放入队列中.由多个线程去处理
	2.优势：
		平衡生产者与消费者的处理能力
	3.为什么要使用生产者和消费之模型：
			生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，
			而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。
			同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。
	4.生产者消费者模型的原理：
		生产者消费者模型是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，
		所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，
		阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。
	5.生产者如何知道队列中的数据被消费完？
		1.生产者端：
			1.每次生产一个数据,放到队列中并刻上一个记号
			2.当生产者全部生产完毕后,一直阻塞着,等待之前被刻上记号的数据消费完后
			  使用join信号感知到后,停止阻塞,生产者进程结束
		2.消费者端：
			1.每次获取一个数据处理后,发送一个记号标志数据被处理成功
25.什么是cdn？

26.LVS是什么及作用？

27.Nginx是什么及作用？
	nginx是一个开源的,支持高性能,高并发的服务器还可以作为反向代理,负载均衡,以及缓存服务使用
	1.支持高并发,能支持几万并发连接
	2.可以独立提供http服务。可以做网页静态服务器。 
	3.资源消耗少,在3万并发连接下开启10个nginx线程消耗的内存不到200M
	4.可以做http反向代理和负载均衡
		
	5.支持异步网络i/o时间模型epoll
28.keepalived是什么及作用?

29.haproxy是什么以及作用？

30.什么是负载均衡？
	反向代理：
			后端服务不直接对外暴露,请求首先发送到nginx,然后nginx将请求转发到后端服务器，
			服务器处理后将结果返回给nginx,只对Nginx负责
		配置反向代理： nginx.conf   >  proxy_pass http://应用服务器的地址	
	负载均衡：Nginx的负载均衡是基于反向代理实现的
		当网站的访问量达到一定程度后,单台服务器不能满足用户的请求时,需要用多台服务器集群来提高效率
		nginx将请求/数据【均匀】分摊到多个操作单元上执行
		多台服务器可以平均分担负载,不会因为某台服务器负载高宕机而某台服务器闲置的情况
	集群：
			集群就是一组（若干个）相互独立的计算机,利用网络组成一个较大的计算机服务器系统,每个节点运行各自的独立服务器。
			服务器之间彼此通信,协同向用户提供应用程序,系统资源和数据。
			当用户请求集群系统时,用户的感知就是一台单一的服务器,其实用户的请求是发给了一组服务器
		集群指的是将几台服务器集中在一起,实现同一业务
		分布式中的每一个节点，都可以做集群
		而集群并不一定就是分布式的
		同样提供10台服务器，每台服务器都能独立处理这个任务。假设有10个任务同时到达，
		10个服务器将同时工作，10小后，10个任务同时完成
		
	分布式：
		如果一个任务由10个子任务组成,每个子任务单独执行需1小时,则在一台服务器上执行改任务需10小时
		采用分布式:
			提供10台服务器，每台服务器只负责处理一个子任务,执行完这个任务只需一个小时
			分布式是指将不同的业务分布在不同的地方
			
		
			
	Nginx轮询的方式:
		1.平均轮询
		2.加权轮询：使用weight参数
		3.ip_hash轮询 根据用户的IP地址进行hash运算，只要是同个用户发的请求，就会被永远地转发在某台服务器上
		4.fair策略 动态weight策略 根据服务器的响应能力进行动态指定的
					fair策略是一个第三方策略
		5.url_hash策略：类似于ip,只不过绑定的值是url，这个也是第三方策略
		url_hash策略的用处：
			url_hash策略比较适合于大型电子商务网站，对于不同的商品便是不同的url,我们可以据此进行负载均衡。
			原理就是不同的商品形成不同的静态页面,然后服务器根据不同商品的火爆程度，按照命中率高的放在缓存里
			加快访问速度，也就是说实现了一个基于缓存的服务器，相当于把有限的缓存最优化起来
31.什么是rpc及应用场景？

32.简述 asynio模块的作用和应用场景。

33.简述gevent模块的作用和应用场景。


34.twisted框架的使用和应用？

#######################补充###################################
	***1.长连接、短连接与WebSocket 的区别
		1.长连接、短连接是基于HTTP协议的
			HTTP的长连接和短连接本质上是TCP长连接和短连接
			HTTP1.0中默认使用短连接,从HTTP1.1起，默认使用长连接，用以保持连接特性
			会在响应头加入:Connection:keep-alive；
			短连接的操作步骤是：
				建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接
			长连接的操作步骤是：建立SOCKET连接后不管是否使用都保持连接,但安全性较差
				建立连接——数据传输 …（保持连接）… 数据传输——关闭连接
			
			使用场景：
				长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。例如：数据库的连接用长连接
				WEB网站的http服务一般都用短链接,因为长连接对于服务端来说会耗费一定的资源,使用短连接会更省一些资源
		
		2.Websocket是基于HTTP协议的一个新的协议,是HTTP协议上的一种补充，但是不等于http协议的长连接(有交集,但是基本没有关系)
			WebSocket服务器和客户端可以彼此相互推送信息,而且WebSocket允许跨域通信。
		
		3.WebSocket的通信流程：
			1.客户端发送请求,服务端获取到Sec-WebSocket-Key
			2.服务端将key值与 magic_string拼接成新字符串,hash后b64加密,将加密后的结果 ret 返回给客户端
			3.握手成功之才能收发数据,服务端收到数据后需要解密
				取第二个字节的后7位,如果取值<=125则数据真实长度就是低7位的值
									如果取值为126,则需要额外的两个字节来表示数据的真实长度
									如果取值127,那么需要额外的8个字节表示数据的真实长度
		
	***2.http一次连接的全过程
	  域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求,
	  浏览器得到html代码 --> 浏览器解析html代码,并请求html代码中的资源（如js、css、图片等）
		--> 浏览器对页面进行渲染呈现给用户
		

		
	***3.同步（Sync）和异步（Async）
		
		1.同步：发出一个功能调用时，在没有得到结果之前，不能继续后面的操作。同步就是必须一件一件事做，等前一件做完了才能做下一件事。
		2.异步：调用者在没有得到结果之前，就可以继续执行后续操作。调用完成后，一般通过状态、通知和回调来通知调用者。
		同步和异步的区别：
			请求发出后，是否需要等待结果，才能继续执行其他操作
			
		关注的是消息通知的机制。主动等候消息则为同步、被动听消息则为异步
	
	
	***4.阻塞和非阻塞：
		关注的是程序在等待调用结果（消息，返回值）时的状态。关注的是等候消息的过程中有没有干其他事

		阻塞和非阻塞这两个概念仅仅与等待消息通知时的状态有关。跟同步、异步没什么太大关系
		阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态
		阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回
		非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程
		
		
		同步阻塞：老张把水壶放到火上，就坐在那里等水开，开了之后我再去看电视。（）
		同步非阻塞：老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）
		老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。
		异步阻塞：老张把响水壶放到火上，然后就坐在旁边等着听那个烧开的提示音。（异步阻塞）
		异步非阻塞：老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。
		
		***5.什么是Http协议？
		    https://www.toutiao.com/a6662159335713407502/
			超文本传输协议，建立在tcp之上，一次请求一次响应然后断开连接（无状态、短连接）
			
			HTTP请求报文：
				一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成
				请求头\r\n\r\n请求体

				1.请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本
				2.请求头部，用来说明服务器要使用的附加信息
				    HOST：指出请求的目的地
				    User-Agent：识别发出请求的浏览器或其他客户端，并可以向不同类型的浏览器返回不同的内容
				    Referer：指示请求是从哪发出的
				    Accept：告诉服务器，客户端支持什么数据类型
				    Accept-Language 客户端支持的语言
				    Cookie	这个头信息把之前发送到浏览器的 cookies 返回到服务器
				 3.第三部分：空行，请求头部后面的空行是必须的
				 4.第四部分：请求数据也叫主体，可以添加任意的其他数据
				
			HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文
				响应头\r\n\r\n响应体
				响应头中的内容：
				    Date：表示消息发送的时间
				    server:服务器名字。
                    Connection：浏览器与服务器之间连接的类型
                    content-type:表示后面的文档属于什么MIME类型
				
			常见的请求方法：GET/POST/DELETE/PUT/PATCH/
				GET：用来向服务器请求指定的资源
				POST：向服务器提交资源让服务器处理，提交的资源放在请求体中
				HEAD：获得报文首部
				PUT：创建一个新的目标资源，或者替换原先的目标资源
				PATCH：对已知资源进行局部更新 
				DELETE：删除文件
				OPTIONS：询问支持的方法  客户端询问服务器可以提交哪些请求方法
				TRACE：回显服务器收到的请求，主要用于测试或诊断。
				CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器
				
			GET和POST请求的区别： 
				1.GET把参数包含在URL中，POST通过request body传递参数 GET的参数是明文传输，不安全
				2.GET请求会被浏览器主动cache，而POST不会
				3.GET请求只能进行url编码，而POST支持多种编码方式
				4.GET请求在URL中传送的参数是有长度限制的（2048），而POST没有
				5.对参数的数据类型，GET只接受ASCII字符，而POST没有限制
				
			
			常见状态代码、状态描述的说明如下。

			200 OK：客户端请求成功。
			301 永久移动。请求的资源已被永久的移动到新URL
			302 临时移动。资源只是临时被移动。客户端应继续使用原有URI
			400 Bad Request：客户端请求有语法错误，不能被服务器所理解。
			401 Unauthorized：请求要求用户的身份认证
			402	Payment Required	保留，将来使用
			403 Forbidden：服务器收到请求，但是拒绝提供服务。
			404 Not Found：请求资源不存在，举个例子：输入了错误的URL。
			500 Internal Server Error：服务器发生不可预期的错误。
			503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常
				
				
		
		Https和Http区别？
			1、首先Https是Http的安全版，即HTTP下加入SSL层就是Https；
			2、默认端口号不同，Http是80端口，Https是443端口；
			3、Http是超文本传输协议，信息是明文传输 Https是需要到ca申请证书
			4.在连接方面，http连接更简单，效率更高。总的来说，http效率更高，https安全性更高
		