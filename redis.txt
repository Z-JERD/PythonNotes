redis的key value长度是多少？均是512MB

1.redis和memcached比较？
	总述：memcached支持的数据类型简单,数据都存在内存中
		  Redis有复杂的数据类型,支持持久化
		1.存储方式
			Memecache把数据全部存在内存之中,数据不能超过内存大小
			Redis有部份存在硬盘上，这样能保证数据的持久性
		2.数据支持类型：
			Memcache对数据类型支持相对简单。
			Redis有复杂的数据类型。
		3.value大小
			redis最大可以达到1GB，而memcache只有1MB
2.redis中数据库默认是多少个db 及作用？
	默认有16个db,默认情况下一个客户端连接到数据库0
	控制数据库总数：
	/etc/redis/redis.conf
	修改databases = 16
3.python操作redis的模块？
	redis模块
	django中使用redis diango-redis
4.如果redis中的某个列表中的数据量非常大，如果实现循环显示每一个值？
	使用scan_iter,迭代取值
	不使用hgetall的原因：从redis中取到数据之后,服务器的内存无法承受

**5.redis如何实现主从复制？以及数据同步机制？
	Redis主从复制可以根据是否是全量分为全量同步和增量同步
	Redis全量复制一般发生在Slave初始化阶段
    1）从服务器连接主服务器，发送SYNC命令； 
　　2）主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； 
　　3）主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； 
　　4）从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； 
　　5）主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； 
　　6）从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令； 
	增量同步:
		主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。
同步机制：主从刚刚连接的时候,进行全量同步；全同步结束后，进行增量同步
		 redis 策略是,无论如何,首先会尝试进行增量同步,如不成功,要求从机进行全量同步。
**6.redis中的sentinel(哨兵)的作用？
	1.监控主机状态,实现高可用
		假如master宕机了,Redis本身都没有实现自动进行主备切换，而Redis-sentinel本身也是一个独立运行的进程，
		它能监控主机状态,发现master宕机后能进行自动切换。
	2.Sentinel支持集群:
		即使有一些sentinel进程宕掉了，依然可以进行redis集群的主备切换；
		如果只有一个sentinel进程，如果这个进程运行出错,那么将无法实现redis集群的主备切换;
		如果有多个sentinel，redis的客户端可以随意地连接任意一个sentinel来获得关于redis集群中的信息
	使用版本：redis2.6(sentinel版本为sentinel 1
7.如何实现redis集群？
	1.客户端分片
	2.使用Redis代理Twemproxy
	3.Redis 3.0集群采用了P2P的模式，完全去中心化。Redis把所有的Key分成了16384个slot，
	每个Redis实例负责其中一部分slot。集群中的所有信息,都通过节点之间定期数据交换而更新
	4.云服务器上的集群服务
8.redis中默认有多少个哈希槽？
	16384

**9.简述redis的有哪几种持久化策略及比较？
	1.RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照
	2.AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，
		  通过重新执行这些命令来还原数据集
	3.Redis 还可以同时使用 AOF 持久化和 RDB 持久化
		当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 
		因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整
	比较：
		RDB适合用于进行备份,随时将数据集还原到不同的版本
		RDB 的缺点:
			一旦发生故障停机， 你就可能会丢失好几分钟的数据。
		AOF 的优点:
		设置不同的 fsync(同步) 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync
		AOF 的默认策略为每秒钟 fsync 一次,就算发生故障停机，也最多只会丢失一秒钟的数据
		AOF 的缺点:
			1.对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。
			2.AOF 的速度可能会慢于 RDB
		3.让 AOF 的速度和 RDB 一样快:关闭 fsync
**10.列举redis支持的过期策略(内存淘汰机制)。
	1.从已设置过期时间的数据集里选择：
				1.volatile-lru：挑选最近最少使用的数据淘汰
				2.volatile-ttl：挑选即将过期的数据淘汰
				3.volatile-random：任意选择数据淘汰
	2.从数据集中选择
		1.allkeys-lru：从数据集中选最少使用的数据淘汰
		2.allkeys-random:从数据集中任意选择数据淘汰
		3.no-enviction：当内存不足以容纳新写入数据时，新写入操作会报错

11.MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中都是热点数据？ 
	redis内存数据级上升到一定大小时,就会实行数据淘汰策略,
12.写代码，基于redis的列表实现 先进先出、后进先出队列、优先级队列。
	先进先出:
	class Queue:
		def __init__(self,conn):
			self.conn=conn
		def push(self,val):
			self.conn.rpush('bb',val)
		def get(self):
			return self.conn.lpop('bb')
	后进先出：
	class Stack:
		def __init__(self,conn):
			self.conn=conn
		def push(self,val):
			self.conn.rpush('bb',val)
		def get(self):
			return self.conn.rpop('bb')
	优先级队列：
	class You:
		def __init__(self,conn):
			self.conn=conn
		def push(self,val,count):
			self.conn.zadd('bb',val,count)
		def get(self):
			a = self.conn.zrange('ccc', 0, 0)[0]
			self.conn.zrem('ccc', a)
			return a
13.如何基于redis实现消息队列？
	redis--list
	将列表维护成一个栈,设置获取数据的超时时间
**14.如何基于redis实现发布和订阅？以及发布订阅和消息队列的区别？
	1.发送消息：
		Redis采用PUBLISH命令发送消息，其返回值为接收到该消息的订阅者的数量。
	2.订阅
		Redis采用SUBSCRIBE命令订阅某个频道，其返回值包括客户端订阅的频道，
		目前已订阅的频道数量，以及接收到的消息
	消息队列：接收消息的只有一个处理者
	发布订阅：所有的订阅者都会收到消息并进行处理
15.什么是codis及作用？

16.什么是twemproxy及作用？
	twitter开源的redis/memcached 代理服务器 管理 Redis 和 Memcached 集群
	redis实现集群的一个方案。有了Twemproxy，客户端不直接访问Redis服务器，
	而是通过twemproxy 代理中间件间接访问。
	作用 : 对redis数据分片处理
		   减少与Cache 服务器直接连接的数量
17.写代码实现redis事务操作。
	大量数据需要一次性操作完成的时候,使用Pipeline进行批处理,将一大队的操作合并成一次操作
	每次请求都会创建和断开一次连接操作,如果想在一次请求中指定多个命令,使用pipline来实现
	调用pipeline方法并将transaction的值改为True
	1.redis启动事务：multi
	2.回滚事务:discard
	3.提交事务:execute
		WATCH命令可以监控一个或多个键，一旦其中有一个键被修改（或删除）
		之后的事务就不会执行，监控一直持续到EXEC命令
	
	
**18.redis中的watch的命令的作用？
	在Redis的事务中，WATCH命令可用于提供CAS(check-and-set)功能。
	假设我们通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生了变化，
	执行的事务都将被放弃，同时返回Null 
	如何控制剩余的数量不会出问题?
	1.通过redis的watch实现
	2.使用数据库的锁
	
19.基于redis如何实现商城商品数量计数器？
	使用事务,并用watch监控

20.简述redis分布式锁和redlock的实现机制。


21.什么是一致性哈希？Python中是否有相应模块？
	Python模块--hash_ring，即Python中的一致性hash

22.如何高效的找到redis中所有以oldboy开头的key？

######################补充############################
1.使用Redis的好处：
	1.速度快。数据都存在内存中
	2.支持多种数据类型：String,list,set,zset,hash
	3.支持事务(pipeline),操作都是原子性的
	4.redis支持数据的持久化 AOF和RDB
	5.Redis支持数据的备份(主从复制)
	
2.Redis客户端和服务端之间使用的通讯协议：RESP
	特点：实现简单,快速解析,可读性好
3.Redis有哪些架构模式:
	1.单机版：只有一个服务器 
		1、内存容量有限 2、处理能力有限 3、无法高可用
	2.主从复制：一个主服务器,多个从服务器
		主服务器就会一直将发生在自己身上的数据更新同步 给从服务器
		1.master/slave 数据相同 2.降低 master 读压力 3.无法保证高可用,没有解决 master 写的压力
	3.哨兵：监控 redis 主从服务器,自动进行故障转移
		三个特性:1.监控 2.提醒 3.自动故障迁移
		特点：1.保证高可用 2.监控各个节点 3.自动故障迁移  没有解决 master 写的压力
	4.集群：Twemproxy 是一个 Twitter 开源的一个 redis 和 memcache 快速/轻量级代理服务器
		特点：1.多种 hash 算法 2.支持失败节点自动删除
		
**4.使用过Redis分布式锁么，它是怎么实现的？
	先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放
	如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样
		set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！
5.使用过Redis做异步队列么，你是怎么用的？有什么缺点？
	一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。
	缺点：
	在消费者下线的情况下,生产的消息会丢失,得使用专业的消息队列如rabbitmq等。
	能不能生产一次消费多次呢？
		可以使用发布订阅模式,所有的订阅者都会收到消息并进行处理
**6.redis为什么这么快?
	(一)纯内存操作
	(二)单线程操作，避免了频繁的上下文切换
	(三)采用了非阻塞I/O多路复用机制
**7.redis的过期策略以及内存淘汰机制
	redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的?数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?
	redis采用的是定期删除+惰性删除策略。
	定期删除,redis默认每个100ms检查，是否有过期的key,有过期key则删除。
	需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查,因此，如果只采用定期删除策略，会导致很多key到时间没有删除。
	惰性删除,就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。
	
	内存占用率还是比较高的原因：如果定期删除没删除key。然后你也没即时去请求key,redis的内存会越来越高。那么就应该采用内存淘汰机制
	
	在redis.conf中有一行配置
	为什么不用定时删除策略?
	定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源
	在大并发请求下，CPU要将时间应用在处理请求，而不是删除key
	
**8.使用redis有什么缺点?
	(一)缓存和数据库双写一致性问题
	(二)缓存雪崩问题
	(三)缓存击穿问题
	(四)缓存的并发竞争问题
	1.数据库和缓存双写,就必然会存在不一致的问题。只能保证最终一致性,降低不一致发生的概率，无法完全避免
	  有强一致性要求的数据，不能放缓存。
	  先更新数据库，再删缓存,可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。
	2.缓存穿透；
		故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常
		解决方案：
		1.利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试
		2.使用拦截机制：
			利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。
	3.缓存雪崩：
		缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常
		1.不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀
		2.使用双缓存,A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期
	4.如何解决redis的并发竞争key问题	
		假如有某个key = "price"，  value值为10，现在想把value值进行+10操作。正常逻辑下，就是先把数据key为price的值读回来，
		加上10，再把值给设置回去。如果只有一个连接的情况下，这种方式没有问题，可以工作得很好，
		但如果有两个连接时，两个连接同时想对还price进行+10操作，就可能会出现问题了。

		例如：两个连接同时对price进行写操作，同时加10，最终结果我们知道，应该为30才是正确。
		1.如果对这个key操作，不要求顺序
			准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。
		2.使用事务+watch
		3.使用消息队列
9.如何保证消息一定被正确处理，下订单之后需要付款，那么在线付款的时候如何保护发送的消息已经被处理成功呢？
是否是需要去查询订单处理状态？然后再判断是否可以付款？
 用户下订单，不能保证成功，只有库存系统检查并分配商品，调整库存之后，才是成功的订单。只有成功的订单，才能付款，
10.如果秒杀商品有100个，当请求达到100个的时候，不再允许请求了，那么如果这100个请求中有消息没有被处理成功，如何解决？
 秒杀逻辑处理将库存分给前100个请求，生成成功的订单，一般的还有产生几十个秒杀排队订单（单独于标准订单，如果前100个中有未付款被取消，则排队订单有效）,
 再后面的就都通知失败
 
11.redis中默认有多少个哈希槽？
	Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽。
	这种结构很容易添加或者删除节点
	当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了；

	当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了；
	用了哈希槽的概念，而没有用一致性哈希算法，不都是哈希么？这样做的原因是为什么呢？
		哈希槽虽然没有一致性hash灵活，但实现很简单，节点增删时处理起来也很方便
	每一个哈希槽中存的key 和 value是什么？
	一个hash slot中会有很多key和value
	insert数据时会根据上面的简单算法来决定你的key应该存在哪个分区，每个分区里有很多key。
	
12.一致性hash
	hash取模法是对服务器的数量进行取模,当服务器数量变动时,所有缓存的位置都要发生改变
	1.一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环,2^32个点组成
	2.将各个服务器使用Hash进行一个哈希,选择服务器的IP或主机名作为关键字进行哈希
		这样每台机器就能确定其在哈希环上的位置
	3.将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置
		沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器
	一致性Hash算法的容错性和可扩展性:
	1.如果一台服务器不可用，则受影响的数据仅仅是此服务器到其前一台服务器,之间数据，其它不会受到影响
	2.如果增加一台服务器，则受影响的数据仅仅是此服务器到其前一台服务器,之间数据，其它不会受到影响
	Hash环的数据倾斜问题:
	如果服务器太少,会造成数据倾(被缓存的对象大部分集中缓存在某一台服务器上）
	为了解决这种数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，
	每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器IP或主机名的后面增加编号来实现
	具体做法可以在服务器IP或主机名的后面增加编号来实现
13.redis的锁：
	redis采用了乐观锁,使用watch命令来监控某一个key,如果事务执行前这个key值发生变化，那么事务将不会执行。
	如果事务执行后这个key，那么事务继续执行。 
	
**14.分布式锁：
		分布式锁是控制分布式系统之间同步访问共享资源的一种方式
		分布式锁：当多个进程不在同一个系统中,用分布式锁控制多个进程对资源的访问
		应用场景：分布式锁应该用来解决分布式情况下的多进程并发问题才是最合适的
		Redis中可以使用SETNX命令实现分布式锁 setnx key value 如果不存在，则设置
		expire key timeout 
			为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。
		del key 命令就能释放锁
		解决死锁：如果一个持有锁的客户端失败或崩溃了不能释放锁，该怎么解决？
			给锁设置一个过期时间，可以通过两种方法实现
			1.通过命令 “setnx 键名 过期时间 
			2.通过设置锁的expire时间，让Redis去删除锁。
		有这样一个情境，线程A和线程B都共享某个变量X。
		如果是单机情况下,线程之间共享内存,只要使用线程锁就可以解决并发问题。
		如果是分布式情况下,线程A和线程B很可能不是在同一系统中，这样线程锁就无法起到作用了，这时候就要用到分布式锁来解决。
		实现的时候要注意的几个关键点：
		1、锁信息必须是会过期超时的，不能让一个线程长期占有一个锁而导致死锁；
		2、同一时刻只能有一个线程获取到锁。
		实现:
			使用的是jedis来连接Redis。
		实现思想:
		1.加锁
		使用setnx加锁，并使用expire命令为锁添加一个超时时间,超过该时间则自动释放锁
		锁的value值为一个随机生成的UUID,作为锁标识
		2.释放锁的时候
			通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放
15.redis中piplin的作用：
	大量数据需要一次性操作完成的时候,使用Pipeline进行批处理,将一大堆的操作合并成一次操作
	每次请求都会创建和断开一次连接操作,如果想在一次请求中指定多个命令,使用pipline来实现