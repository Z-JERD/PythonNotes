链表参考文档：https://blog.csdn.net/Plus_L/article/details/82597514
              https://www.toutiao.com/a6587279377090740744/
1.数组：数据是连续的；随机访问速度快
    当创建数组时会在内存中划分出一块连续的内存，然后当有数据进入的时候会将数据按顺序的存储在这块连续的内存中。
    当需要读取数组中的数据时，需要提供数组中的索引，然后数组根据索引将内存中的数据取出来，返回给读取程序。
2.数组 读取、插入、删除：
   数组在存储数据时是按顺序存储的，存储数据的内存也是连续的，所以他的特点就是寻址读取数据比较容易，插入和删除比较困难。
   简单解释一下为什么，在读取数据时，只需要告诉数组要从哪个位置（索引）取数据就可以了，数组会直接把你想要的位置的数据取出来给你。
   插入和删除比较困难是因为这些存储数据的内存是连续的，要插入和删除就需要变更整个数组中的数据的位置。这可是很耗时的

  数组的优点：
    1.随机访问性高
    2.查找速度快

  数组的缺点：
    插入和删除效率低
    不易于扩展
    对内存要求高，需要连续的空间
    有可能造成内存的浪费


3.链表结构：
    创建链表时不会先划出一块连续的内存。因为链表中的数据并不是连续的
    链表结构是由许多节点构成的，每个节点都包含两部分：
        1.数据部分：保存该节点的实际数据。
        2.地址部分：保存的是下一个节点的地址。
4.链表的优点：
    1.插入、删除速度快
    2.内存利用率高，不浪费
    3.易于扩展
    数据元素的个数可以自由扩充 、插入、删除等操作不必移动数据，只需修改链接指针，修改效率较高
5.链表的缺点:不能随机访问，查找效率低
    存储密度小 、存取效率不高，必须采用顺序存取，即存取数据元素时，只能按链表的顺序进行访问。
    访问时只能通过头指针进入链表，并通过每个结点的 指针域向后扫描其余结点

时间复杂度：
                数组                              链表

读取：       O(1)                               O(n)

添加：       O(n)                               O(1)

删除：       O(n)                               O(1)



树的种类：
    1.无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；
    2.有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；
    3.二叉树：每个节点最多含有两个子树的树称为二叉树；
    4.完全二叉树：如果一个二叉树除了最后一层外的每一个节点数都是最大节点数，那么它就是完全二叉树
    5.满二叉树：如果一个二叉树的每一个节点数都是最大节点数
    6.排序二叉树（二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树）；
    7.平衡二叉树（AVL树）：
        1.本身首先是一棵二叉查找树。
        2.带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。
    8.红黑树：本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，
      从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。

    9.B树

数组的使用场景：查找
    在有序数组中，可以快速找到特定的值，但是想在有序数组中插入一个新的数据项，就必须首先找出新数据项插入的位置，
    然后将比新数据项大的数据项向后移动一位，来给新的数据项腾出空间，删除同理，这样移动很费时。
    显而易见，如果要做很多的插入和删除操作和删除操作，就不该选用有序数组。

链表的使用场景：插入和删除操作
    链表中可以快速添加和删除某个数据项，但是在链表中查找数据项可不容易，必须从头开始访问链表的每一个数据项，
    直到找到该数据项为止，这个过程很慢。


二叉搜索树(binary search tree)：时间复杂度为O(nlogn)  又称二叉查找树和二叉排序树
    树这种数据结构，既能像链表那样快速的插入和删除，又能想有序数组那样快速查找。
    这里主要实现一种特殊的树——二叉（搜索）树。
    二叉搜索树有如下特点：
    1.所有非叶子结点至多拥有两个儿子
    2.所有结点存储一个关键字；
    3.一个节点的左子节点的关键字值小于这个节点，右子节点的关键字值大于或等于这个节点。插入一个节点需要根据这个规则进行插入。


B树(B-tree)和B+树：
参考文档：https://www.toutiao.com/a6657389440857539086/
1.B树： 时间复杂度 O(logn)
    1.B树概念：
        B树是一种多路搜索树，它的每个节点可以拥有多于2个孩子节点
    2.B树的特征：
        1.根节点至少有两个子节点
        2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 ≤ k ≤ m （m为树的阶）
        3.每个节点中的元素从小到大排列
    3.B树的操作
        1.B树的查找: 查询元素8
            第一次磁盘IO：把15所在节点读到内存中，然后与8做比较，小于15，找到下一个节点（5和9对应的节点）

            第二次磁盘IO：把5和9所在的节点读到内存中，然后与8做比较，5<8<9，找到下一个节点（6和8对应的节点）

            第三次磁盘IO：把6和8所在节点读到内存中，然后与8做比较，找到了元素8

        2.B树的插入:将元素7插入下图中的B树
            步骤一：自顶向下查找元素7应该在的位置，即在6和8之间

            步骤二：三阶B树中的节点最多有两个元素，把6 7 8里面的中间元素上移（中间元素上移是插入操作的关键）

            步骤三：上移之后，上一层节点元素也超载了，5 7 9中间元素上移，现在根节点变为了 7 15

            步骤四：要对B树进行调整

    4.B树为什么要设计成多路？可以设计成无限多路吗?
        设计多路的目的是为了降低树的高度，路数越多，树的高度越低。但是不限制路数，就会退化为有序数组

    5.B树的使用场景：
        B树一般用于文件系统的索引，文件系统和数据库的索引都是存在硬盘上的，并且如果数据量大的话，不一定能一次性加载到内存中
        B树的多路搜索的优势就在于每次加载树的一个节点，然后一步步往下查。
        比如数据  25 25 30 40 43 45 50 59 65 77 85
        假如内存一次性只能加载2个数，这么长的有序数组是无法一次性存进内存的。可以把它组织成三路的B树，每个节点最多2个元素
        查找的时候，每次载入一个节点



B+树:
    B+树是在B树的基础上进行改造，它的数据都在叶子节点上，同时叶子结点之间还加了指针形成了链表

    B+树的使用场景：
        B+树主要用在数据库的索引上。数据库中select数据，不一定只选一条，很多时候会选多条。如果是多条的话，B树需要做局部的中序遍历，
        可能要跨层访问。而B+树由于所有数据都在叶子结点，不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了

    B+树的优势：
        1.B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key，数据存放的更加紧密
        2.B+树的叶子节点都是相连的，因此对整棵树的遍历只需要一次线性遍历叶子节点即可。而B树则需要进行每一层的递归遍历。
          相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好

B*树：
    是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；将结点的最低利用率从1/2提高到2/3；


**二叉查找树的时间复杂度是Ｏ(logN)，效率已经足够高。为什么出现B树和B+树呢？
    当大量数据存储在磁盘上，进行查询操作时，需要先将数据加载到内存中（磁盘IO操作），而数据并不能一次性全部加载到内存中，
    只能逐一加载每个磁盘页（对应树的一个节点），并且磁盘IO操作很慢，平衡二叉树由于树深度过大而造成磁盘IO读写过于频繁，
    进而导致效率低下。为了减少磁盘IO的次数，就需要降低树的深度，那么就引出了B树和B+树：每个节点存储多个元素，采用多叉树结构。
    这样就提高了效率，比如数据库索引，就是存储在磁盘上，采用的就是B+树的数据结构
